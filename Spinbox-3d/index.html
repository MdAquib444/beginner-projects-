<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Centered Cube</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById('glcanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const gl = canvas.getContext('webgl');
if (!gl) {
  alert('WebGL not supported');
  throw new Error('WebGL not supported');
}

// === SHADERS ===
const vsSource = `
  attribute vec4 a_position;
  uniform mat4 u_matrix;
  void main() {
    gl_Position = u_matrix * a_position;
  }
`;

const fsSource = `
  precision mediump float;
  void main() {
    gl_FragColor = vec4(0.2, 0.8, 1.0, 1.0); // Cyan cube
  }
`;

// === Shader setup ===
function createShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vs, fs) {
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  return prog;
}

const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = createProgram(gl, vs, fs);
gl.useProgram(program);

// === Cube geometry ===
const cubeSize = 50 / Math.min(canvas.width, canvas.height); // normalize size
const s = cubeSize;

const positions = new Float32Array([
  -s, -s,  s,  s, -s,  s,  -s,  s,  s,  s,  s,  s,   // front
  -s, -s, -s, -s,  s, -s,   s, -s, -s,  s,  s, -s    // back
]);

const indices = new Uint16Array([
  0, 1, 2,  2, 1, 3,    // front
  4, 5, 6,  6, 5, 7,    // back
  5, 2, 7,  7, 2, 3,    // top
  4, 6, 0,  0, 6, 1,    // bottom
  6, 7, 1,  1, 7, 3,    // right
  4, 0, 5,  5, 0, 2     // left
]);

const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

const aPos = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

const uMatrix = gl.getUniformLocation(program, 'u_matrix');

// === Matrices ===
function perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  return [
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (near+far)/(near - far), -1,
    0, 0, (2*near*far)/(near - far), 0
  ];
}

function translation(tx, ty, tz) {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    tx, ty, tz, 1
  ];
}

function multiply(a, b) {
  const out = new Array(16).fill(0);
  for (let i = 0; i < 4; i++)
    for (let j = 0; j < 4; j++)
      for (let k = 0; k < 4; k++)
        out[i*4+j] += a[i*4+k] * b[k*4+j];
  return out;
}

// === Draw ===
function draw() {
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  const aspect = canvas.width / canvas.height;
  const proj = perspective(Math.PI / 4, aspect, 0.1, 100);
  const modelView = translation(0, 0, -3); // move cube into view

  const finalMatrix = multiply(proj, modelView);

  gl.uniformMatrix4fv(uMatrix, false, new Float32Array(finalMatrix));
  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
}

draw();
</script>
</body>
</html>