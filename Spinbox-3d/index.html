<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Static Cube</title>
  <style>
    body, html {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');

if (!gl) {
  alert("WebGL not supported");
  throw new Error("WebGL not supported");
}

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);

// Shaders
const vsSource = `
  attribute vec4 a_position;
  uniform mat4 u_matrix;
  void main() {
    gl_Position = u_matrix * a_position;
  }
`;

const fsSource = `
  precision mediump float;
  void main() {
    gl_FragColor = vec4(0.2, 0.8, 1.0, 1.0);
  }
`;

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}

function createProgram(vs, fs) {
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  return program;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
const program = createProgram(vs, fs);
gl.useProgram(program);

// Proper cube with duplicated vertices for each face
const positions = new Float32Array([
  // Front
  -1, -1,  1,
   1, -1,  1,
  -1,  1,  1,
   1,  1,  1,
  // Back
  -1, -1, -1,
  -1,  1, -1,
   1, -1, -1,
   1,  1, -1,
  // Top
  -1,  1, -1,
  -1,  1,  1,
   1,  1, -1,
   1,  1,  1,
  // Bottom
  -1, -1, -1,
   1, -1, -1,
  -1, -1,  1,
   1, -1,  1,
  // Right
   1, -1, -1,
   1,  1, -1,
   1, -1,  1,
   1,  1,  1,
  // Left
  -1, -1, -1,
  -1, -1,  1,
  -1,  1, -1,
  -1,  1,  1,
]);

const indices = new Uint16Array([
  0, 1, 2,  2, 1, 3,       // front
  4, 5, 6,  6, 5, 7,       // back
  8, 9,10, 10, 9,11,       // top
 12,13,14, 14,13,15,       // bottom
 16,17,18, 18,17,19,       // right
 20,21,22, 22,21,23        // left
]);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

const uMatrix = gl.getUniformLocation(program, "u_matrix");

// Matrix math
function perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1 / (near - far);
  return [
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) * nf, -1,
    0, 0, (2 * far * near) * nf, 0,
  ];
}

function translationMatrix(x, y, z) {
  return [
    1,0,0,0,
    0,1,0,0,
    0,0,1,0,
    x,y,z,1
  ];
}

function multiply(a, b) {
  const out = new Array(16).fill(0);
  for (let i = 0; i < 4; i++)
    for (let j = 0; j < 4; j++)
      for (let k = 0; k < 4; k++)
        out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
  return out;
}

// Draw once
gl.clearColor(0, 0, 0, 1);
gl.enable(gl.DEPTH_TEST);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

const aspect = canvas.width / canvas.height;
const projection = perspective(Math.PI / 4, aspect, 0.1, 100);
const view = translationMatrix(0, 0, -6);
const matrix = multiply(projection, view);

gl.uniformMatrix4fv(uMatrix, false, new Float32Array(matrix));
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
</script>
</body>
</html>