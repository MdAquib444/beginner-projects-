<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGL Cube</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #error {
      position: absolute;
      top: 10px;
      left: 10px;
      color: red;
      background: rgba(0,0,0,0.6);
      padding: 8px;
      font-family: monospace;
      z-index: 999;
    }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>
  <div id="error"></div>
  <script>
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');

    function showError(msg) {
      document.getElementById('error').textContent = msg;
    }

    if (!gl) {
      showError("WebGL not supported");
      throw new Error("WebGL not supported");
    }

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);

    const vsSource = `
      attribute vec4 a_position;
      uniform mat4 u_matrix;
      void main() {
        gl_Position = u_matrix * a_position;
      }
    `;

    const fsSource = `
      precision mediump float;
      void main() {
        gl_FragColor = vec4(0.1, 0.7, 1.0, 1.0);
      }
    `;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const msg = gl.getShaderInfoLog(shader);
        showError("Shader Error:\n" + msg);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);

    function createProgram(vs, fs) {
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        showError("Program Error:\n" + gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(vertexShader, fragmentShader);
    gl.useProgram(program);

    const positions = new Float32Array([
      // Front
      -1,-1, 1,  1,-1, 1,  -1, 1, 1,  1, 1, 1,
      // Back
      -1,-1,-1,  1,-1,-1,  -1, 1,-1,  1, 1,-1,
    ]);

    const indices = new Uint16Array([
      0,1,2,  2,1,3,  // front
      5,4,7,  7,4,6,  // back
      2,3,6,  6,3,7,  // top
      0,1,4,  4,1,5,  // bottom
      0,2,4,  4,2,6,  // left
      1,3,5,  5,3,7   // right
    ]);

    const posBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

    const uMatrix = gl.getUniformLocation(program, 'u_matrix');

    function perspective(fov, aspect, near, far) {
      const f = 1 / Math.tan(fov / 2);
      const nf = 1 / (near - far);
      return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * near * far) * nf, 0
      ];
    }

    function rotationY(angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      return [
        c, 0, -s, 0,
        0, 1,  0, 0,
        s, 0,  c, 0,
        0, 0,  0, 1
      ];
    }

    function translation(z) {
      return [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, z, 1
      ];
    }

    function multiply(a, b) {
      const out = new Array(16);
      for (let i = 0; i < 4; i++)
        for (let j = 0; j < 4; j++) {
          out[i * 4 + j] = 0;
          for (let k = 0; k < 4; k++)
            out[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
        }
      return out;
    }

    let angle = 0;

    function render() {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      const proj = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
      const rot = rotationY(angle);
      const trans = translation(-6);
      const matrix = multiply(proj, multiply(trans, rot));

      gl.uniformMatrix4fv(uMatrix, false, new Float32Array(matrix));
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

      angle += 0.01;
      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>